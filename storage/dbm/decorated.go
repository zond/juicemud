// Code generated by generator, DO NOT EDIT.
package dbm

import (
	gojson "github.com/goccy/go-json"
	"sync"
)

type PostUnmarshaler interface {
	PostUnmarshal()
}
type PostUnlockLive func(*Live)

func (f PostUnlockLive) call(v *Live) {
	if f != nil {
		f(v)
	}
}

type Live struct {
	// Unsafe permits direct unsynchronized access to the underlying data.
	// Use Get*/Set* methods for thread-safe access, or Lock()/RLock() when accessing Unsafe directly.
	Unsafe     *LiveDO
	PostUnlock PostUnlockLive `faker:"-" json:"-"`
	mutex      sync.RWMutex
	// jsMutex serializes JavaScript execution for this object.
	jsMutex sync.Mutex
}

func (v *Live) UnsafeShallowCopy() *Live {
	return &Live{
		Unsafe:     v.Unsafe,
		PostUnlock: v.PostUnlock,
	}
}
func (v *Live) Describe() string {
	b, _ := gojson.MarshalIndent(v.Unsafe, "", "  ")
	return string(b)
}
func (v *Live) Lock() {
	v.mutex.Lock()
}
func (v *Live) Unlock() {
	v.mutex.Unlock()
	v.PostUnlock.call(v)
}
func (v *Live) RLock() {
	v.mutex.RLock()
}
func (v *Live) RUnlock() {
	v.mutex.RUnlock()
}
func (v *Live) JSLock() {
	v.jsMutex.Lock()
}
func (v *Live) JSUnlock() {
	v.jsMutex.Unlock()
}
func (v *Live) Size() int {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Size()
}
func (v *Live) Marshal(b []byte) {
	v.RLock()
	defer v.RUnlock()
	v.Unsafe.Marshal(b)
}
func (v *Live) Unmarshal(b []byte) error {
	v.Lock()
	defer v.Unlock()
	v.Unsafe = new(LiveDO)
	if err := v.Unsafe.Unmarshal(b); err != nil {
		return err
	}
	if pu, ok := any(v.Unsafe).(PostUnmarshaler); ok {
		pu.PostUnmarshal()
	}
	return nil
}
func (v *Live) SetPostUnlock(p func(*Live)) {
	v.PostUnlock = p
}
func (v *Live) MarshalJSON() ([]byte, error) {
	v.RLock()
	defer v.RUnlock()
	return gojson.Marshal(v.Unsafe)
}
func (v *Live) UnmarshalJSON(data []byte) error {
	v.Lock()
	defer v.Unlock()
	if v.Unsafe == nil {
		v.Unsafe = new(LiveDO)
	}
	return gojson.Unmarshal(data, v.Unsafe)
}
func (v *Live) GetId() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Id
}
func (v *Live) SetId(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Id = p
}
func (v *Live) GetI() int {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.I
}
func (v *Live) SetI(p int) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.I = p
}
func (v *Live) GetS() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.S
}
func (v *Live) SetS(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.S = p
}
