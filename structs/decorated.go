// Code generated by generator, DO NOT EDIT.
package structs

import (
	gojson "github.com/goccy/go-json"
	"sync"
)

type PostUnmarshaler interface {
	PostUnmarshal()
}
type PostUnlockObject func(*Object)

func (f PostUnlockObject) call(v *Object) {
	if f != nil {
		f(v)
	}
}

type Object struct {
	// Unsafe permits direct unsynchronized access to the underlying data.
	// Use Get*/Set* methods for thread-safe access, or Lock()/RLock() when accessing Unsafe directly.
	Unsafe     *ObjectDO
	PostUnlock PostUnlockObject `faker:"-" json:"-"`
	mutex      sync.RWMutex
	// jsMutex serializes JavaScript execution for this object.
	// IMPORTANT: Callbacks must NOT synchronously run JS on other objects
	// while holding this lock, or deadlock could occur. Use emit() which
	// enqueues events asynchronously via the queue.
	jsMutex sync.Mutex
}

func (v *Object) UnsafeShallowCopy() *Object {
	return &Object{
		Unsafe:     v.Unsafe,
		PostUnlock: v.PostUnlock,
	}
}
func (v *Object) Describe() string {
	b, _ := gojson.MarshalIndent(v.Unsafe, "", "  ")
	return string(b)
}
func (v *Object) Lock() {
	v.mutex.Lock()
}
func (v *Object) Unlock() {
	v.mutex.Unlock()
	v.PostUnlock.call(v)
}
func (v *Object) RLock() {
	v.mutex.RLock()
}
func (v *Object) RUnlock() {
	v.mutex.RUnlock()
}
func (v *Object) JSLock() {
	v.jsMutex.Lock()
}
func (v *Object) JSUnlock() {
	v.jsMutex.Unlock()
}
func (v *Object) Size() int {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Size()
}
func (v *Object) Marshal(b []byte) {
	v.RLock()
	defer v.RUnlock()
	v.Unsafe.Marshal(b)
}
func (v *Object) Unmarshal(b []byte) error {
	v.Lock()
	defer v.Unlock()
	v.Unsafe = new(ObjectDO)
	if err := v.Unsafe.Unmarshal(b); err != nil {
		return err
	}
	if pu, ok := any(v.Unsafe).(PostUnmarshaler); ok {
		pu.PostUnmarshal()
	}
	return nil
}
func (v *Object) SetPostUnlock(p func(*Object)) {
	v.PostUnlock = p
}
func (v *Object) MarshalJSON() ([]byte, error) {
	v.RLock()
	defer v.RUnlock()
	return gojson.Marshal(v.Unsafe)
}
func (v *Object) UnmarshalJSON(data []byte) error {
	v.Lock()
	defer v.Unlock()
	if v.Unsafe == nil {
		v.Unsafe = new(ObjectDO)
	}
	return gojson.Unmarshal(data, v.Unsafe)
}
func (v *Object) GetId() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Id
}
func (v *Object) SetId(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Id = p
}
func (v *Object) GetCallbacks() map[string]map[string]bool {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Callbacks
}
func (v *Object) SetCallbacks(p map[string]map[string]bool) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Callbacks = p
}
func (v *Object) GetState() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.State
}
func (v *Object) SetState(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.State = p
}
func (v *Object) GetLocation() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Location
}
func (v *Object) SetLocation(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Location = p
}
func (v *Object) GetContent() map[string]bool {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Content
}
func (v *Object) SetContent(p map[string]bool) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Content = p
}
func (v *Object) GetLearning() bool {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Learning
}
func (v *Object) SetLearning(p bool) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Learning = p
}
func (v *Object) GetSkills() map[string]Skill {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Skills
}
func (v *Object) SetSkills(p map[string]Skill) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Skills = p
}
func (v *Object) GetDescriptions() []Description {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Descriptions
}
func (v *Object) SetDescriptions(p []Description) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Descriptions = p
}
func (v *Object) GetExits() []Exit {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Exits
}
func (v *Object) SetExits(p []Exit) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Exits = p
}
func (v *Object) GetSourcePath() string {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.SourcePath
}
func (v *Object) SetSourcePath(p string) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.SourcePath = p
}
func (v *Object) GetSourceModTime() int64 {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.SourceModTime
}
func (v *Object) SetSourceModTime(p int64) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.SourceModTime = p
}
func (v *Object) GetMovement() Movement {
	v.RLock()
	defer v.RUnlock()
	return v.Unsafe.Movement
}
func (v *Object) SetMovement(p Movement) {
	v.Lock()
	defer v.Unlock()
	v.Unsafe.Movement = p
}
