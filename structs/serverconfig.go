package structs

import (
	"maps"
	"sync"
	"time"

	goccy "github.com/goccy/go-json"
)

// ServerConfig holds server-wide configuration with thread-safe access.
// All fields are private and accessed via getters/setters that handle locking.
type ServerConfig struct {
	mu                 sync.RWMutex
	spawn              string                    // Container ID for spawning new users
	skillConfigs       map[string]SkillConfig    // Per-skill configs (Recharge, Reuse, Forget)
	challengeDurations map[string]SkillDuration  // Per-skill-combo durations, keyed by SkillsKey()
	bodyConfigs        map[string]BodyConfig     // Body type configs (humanoid, quadruped, etc.)
	damageTypes        map[string]DamageTypeConfig // Damage type configs (slashing, piercing, etc.)
}

// NewServerConfig creates a new ServerConfig with initialized maps.
func NewServerConfig() *ServerConfig {
	return &ServerConfig{
		skillConfigs:       make(map[string]SkillConfig),
		challengeDurations: make(map[string]SkillDuration),
		bodyConfigs:        make(map[string]BodyConfig),
		damageTypes:        make(map[string]DamageTypeConfig),
	}
}

// GetSpawn returns the spawn container ID.
func (c *ServerConfig) GetSpawn() string {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.spawn
}

// SetSpawn sets the spawn container ID.
func (c *ServerConfig) SetSpawn(container string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.spawn = container
}

// DefaultSkillConfig returns the default configuration for unconfigured skills.
// - Recharge: 0 (no cooldown)
// - Forget: 2 months (skills decay without practice)
// - Reuse: 0 (no carryover of depleted state)
func DefaultSkillConfig() SkillConfig {
	return SkillConfig{
		Recharge: 0,
		Forget:   Duration(60 * 24 * time.Hour), // 2 months
		Reuse:    0,
	}
}

// GetSkillConfig returns the config for a skill, merging with defaults.
// Always returns a valid config - unconfigured skills get DefaultSkillConfig().
func (c *ServerConfig) GetSkillConfig(name string) SkillConfig {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if cfg, ok := c.skillConfigs[name]; ok {
		return cfg
	}
	return DefaultSkillConfig()
}

// GetChallengeDuration returns the duration for a skill combination, or 0 if not found.
// The key should be generated by SkillsKey().
func (c *ServerConfig) GetChallengeDuration(skillsKey string) SkillDuration {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.challengeDurations[skillsKey]
}

// SetChallengeDuration sets the duration for a skill combination.
func (c *ServerConfig) SetChallengeDuration(skillsKey string, duration SkillDuration) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.challengeDurations == nil {
		c.challengeDurations = make(map[string]SkillDuration)
	}
	c.challengeDurations[skillsKey] = duration
}

// SetSkillConfig sets a skill config.
func (c *ServerConfig) SetSkillConfig(name string, cfg SkillConfig) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.skillConfigs == nil {
		c.skillConfigs = make(map[string]SkillConfig)
	}
	c.skillConfigs[name] = cfg
}

// DeleteSkillConfig removes a skill config.
func (c *ServerConfig) DeleteSkillConfig(name string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.skillConfigs, name)
}

// GetBodyConfig returns the body config for a type, or the default humanoid if not found.
func (c *ServerConfig) GetBodyConfig(name string) BodyConfig {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if cfg, ok := c.bodyConfigs[name]; ok {
		return cfg
	}
	// Return default humanoid if not configured
	defaults := DefaultBodyConfigs()
	if cfg, ok := defaults[name]; ok {
		return cfg
	}
	return defaults["humanoid"]
}

// SetBodyConfig sets a body config.
func (c *ServerConfig) SetBodyConfig(name string, cfg BodyConfig) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.bodyConfigs == nil {
		c.bodyConfigs = make(map[string]BodyConfig)
	}
	c.bodyConfigs[name] = cfg
}

// GetDamageType returns the damage type config, or a default config if not found.
func (c *ServerConfig) GetDamageType(name string) DamageTypeConfig {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if cfg, ok := c.damageTypes[name]; ok {
		return cfg
	}
	// Return default if configured
	defaults := DefaultDamageTypes()
	if cfg, ok := defaults[name]; ok {
		return cfg
	}
	// Unknown damage type - return neutral defaults
	return DamageTypeConfig{SeverMult: 0.5, BleedingMult: 0.5}
}

// SetDamageType sets a damage type config.
func (c *ServerConfig) SetDamageType(name string, cfg DamageTypeConfig) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.damageTypes == nil {
		c.damageTypes = make(map[string]DamageTypeConfig)
	}
	c.damageTypes[name] = cfg
}

// ReplaceSkillConfigs replaces all skill configs atomically.
// Makes a defensive copy of the provided map.
func (c *ServerConfig) ReplaceSkillConfigs(configs map[string]SkillConfig) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.skillConfigs = maps.Clone(configs)
}

// SkillConfigsSnapshot returns a copy of all skill configs for serialization.
// Always returns a non-nil map (empty if no configs) so callers can iterate safely.
func (c *ServerConfig) SkillConfigsSnapshot() map[string]SkillConfig {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if c.skillConfigs == nil {
		return make(map[string]SkillConfig)
	}
	return maps.Clone(c.skillConfigs)
}

// serverConfigJSON is the JSON serialization format for ServerConfig.
// Used for persistence to root object state.
type serverConfigJSON struct {
	Spawn struct {
		Container string
	}
	SkillConfigs       map[string]SkillConfig
	ChallengeDurations map[string]SkillDuration
	BodyConfigs        map[string]BodyConfig
	DamageTypes        map[string]DamageTypeConfig
}

// MarshalJSON implements json.Marshaler for ServerConfig.
func (c *ServerConfig) MarshalJSON() ([]byte, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	j := serverConfigJSON{
		SkillConfigs:       maps.Clone(c.skillConfigs),
		ChallengeDurations: maps.Clone(c.challengeDurations),
		BodyConfigs:        maps.Clone(c.bodyConfigs),
		DamageTypes:        maps.Clone(c.damageTypes),
	}
	j.Spawn.Container = c.spawn

	return goccy.Marshal(j)
}

// UnmarshalJSON implements json.Unmarshaler for ServerConfig.
func (c *ServerConfig) UnmarshalJSON(data []byte) error {
	var j serverConfigJSON
	if err := goccy.Unmarshal(data, &j); err != nil {
		return err
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	c.spawn = j.Spawn.Container
	if j.SkillConfigs == nil {
		c.skillConfigs = make(map[string]SkillConfig)
	} else {
		c.skillConfigs = j.SkillConfigs
	}
	if j.ChallengeDurations == nil {
		c.challengeDurations = make(map[string]SkillDuration)
	} else {
		c.challengeDurations = j.ChallengeDurations
	}
	if j.BodyConfigs == nil {
		c.bodyConfigs = make(map[string]BodyConfig)
	} else {
		c.bodyConfigs = j.BodyConfigs
	}
	if j.DamageTypes == nil {
		c.damageTypes = make(map[string]DamageTypeConfig)
	} else {
		c.damageTypes = j.DamageTypes
	}

	return nil
}
